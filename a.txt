Brod Net concept
================

The network is going to cover two modes of operation.

1. Mesh network
2. Owerlay network

And should serve the following

1. Content Hash Keys
2. Named Files
3. Keyword Searches
4. MeSsages

Units
-----

The source code is divided into following units.

 File       | Description 
-----------:|-------------
[Peers]		| Client evidence. Akafukas.
[Neighb] 	| Evidence of neighbours and hop-based routing.
[Share]		| Searching. Delivery of results.
[Tag]		| Tags hashing. Tags of files and peers. Matching tags.
[Transfer]	| CHK file transfer.
[DataBase]	| Generic 4-dimensional file database.
[NetAddr]	| Network address abstraction.
[Keys]		| Cryptographic operations and data structures.
[Test]		| Unit Tests.
[brodnetd] 	| The Daemon.
[Controll] 	| Controll interface and controll command processing.
[brodnetctl] 	| Command-line interface to daemon.
[WebInterface] 	| Web-based interface to daemon.
[bnctl]		| Managment tool.

[Peers]: Peers.pas
[Share]: Share.pas
[Tag]: Tag.pas
[Transfer]: Transfer.pas
[DataBase]: DataBase.pas
[NetAddr]: NetAddr.pas
[Keys]: Keys.pas
[Log]: Log.pas
[Test]: Test.pas "Unit Tests"
[bncommon]: bncommon.pp
[bnd]: bnd.pp
[bnctl]: bnctl.pp

Daemons and Services
--------------------

Main daemon is always resident in memory, and listens for connections from 
other peers as well as for connections to the controll interface. 
Currently, multiple bind addresses, of both IPv4 and IPv6 protocol, are 
supported. Currently only one listen address is supported for controll 
interface.

Daemon is running in a infinite loop. There is a Select system call, to 
wait for data on lisenning sockets. Timeout is configured for the select 
call and if nothing arrives in the time, tasks sheduled for idle time are 
run. When data is available on one of the sockets, it is processed and 
acted uppon.

### BrodnetCtrl

Local node can be controlled by brodnetctl program. This program is 
interactive, it connects to daemon and waits for user input or event from 
daemon. All events are printed to output in sqare brackets. If nothing 
happens in 5 seconds a single dot is written to output. This program takes 
one optional argument:

	Usage: brodnetctl [-s <address>] [--daemon-address=<address>]

	-s <addr> --daemon-address=<addr> : Specify an TCP/IP address of daemon controll interface to connect to.

Availeble commands in the program are:

command | descr | %1 | %2
--------|-------|----|----
(empty)	| Stop receiving events and wait only for user input.
q       | Disconnect and exit.
stop    | Terminate the daemon.
(peer)states | Toggle receiving various events. Disabled by default.
TransReq	| Manual request to download a CHK. | FID (SHA-1) | Address ofpeer
TransAbort	| Cancel the transfer. | FID
TransStat	| Get status of a transfer. | FID
TransList	| List all incoming transfers.
NeighbList	| List all neighbours.
Route		| List all routes to a node. | PID
addpeer | Connect to peer. | address

impl| netaddr syntax	| meaning
----|-----------------|--------
yes	| //ip4/127.0.0.1/32					| IP4, port 32 UDP
yes	| //ip6/2001:0db8:85a3:0000:0000:8a2e:0370:7334/32	| IP6, port 32 UDP
no	| //bluetooth/00:10:C6:F7:5B:AC/l2cap/4567	| bluetooth
no	| /dev/ttyS0							| character device
no	| /tmp/foobar							| unix domain socket

Discovery
---------

Unimplemeted.

The node finds its peers using local area node discovery (LAND). It is 
performed by sending Akafuka packet to all devices in range of all network 
interfaces (broadcast).

The second mode of discovery is wide area node discovery (WAND). It is 
performed by sending request to all peers in node list, which 
should reply with list of nodes. The node then tryies to send Akafuka packet 
to discovered nodes directly. If successfull (eg: in Internet), it uses 
them as peers. If unsuccessfull (eg: in Meshnet), it updates its routing 
table (tags on the sender).

Greetings (Akafuka Fundeluka)
------------------

Akafuka is used to find new peers (LAND) as well as to check 
availability of peers (like PING).

When a peer appears or disappears an event is sent to other parts of 
daemon.

- Controll: send event on controll interface
- Neighb: update and propagate neighbour database

The names are reference to DÃ¡vid and his awesome Zidan Power.
 
File Sharing
------------

*unimplemented*

Files in the network can have tags. Files are _found_ only by their tags. 
And identified by their hash.

Search request (Request) and reply (Offer) is done with packet of the same 
structure. The only difference is pktype field and that fh field can be null in 
Search packets.

Searching for a file is performed by sending Share.tRequest packet to some 
peers. This packed is acknowledged by Share.tAccept or Share.tReject.
Peers should search in their datastore 
or ask their peers. As soon as they find something, they send back a 
Share.tOffer packet. If the search is satisfied, Transfer is initiated.

Share.tOffer can be recieved and will be handled even if no Share.tRequest 
has been sent.

### Avoiding Routing Loop

When a Share packet arrives, it is forwarded to interested peers 
only if tags in the packet differ from the ones in the files.db.

If the packet is Request, search.db is checked and if we are also 
interested in resuilts from the serach, we forward the same packet back to 
sender. He adds our id to subs.dat in his search.db. Subs.dat is read when 
node finds resuilt for the search and the resuilts are forwarded to peers 
listed there.

Tags
----

*unimplemented*

Every file has tags.
Even nodes have tags.
Tags are used to find files. 

But files have max of 200 tags (to not fragment search packets).

### Searching

For all tags in the query: FileIDs from %tag%.dat are all 
added to in-memory linked-list, but for files already in the list, count 
field is increased and the entry is moved closer to start of the list. 

Finally, the list contains best resuilts near the start. Only first 
cResuitsCount is sent to subscrier.

File Transfer
-------------

[File Transfer][Transfer] is used to copy files or parts of files ower the 
network. Files are identified by SHA1 hash of their contents.

Files are split to 512B blocks. Usually 4 blocks are requested in a single 
packet and up to 12 blocks perrequest is allowed. All data packets have a 
transfer ID and part number. Transfer id is used instead of tFTD to save 
traffic (1 vs 20 bytes). Transfer id is set in request. There is a info 
packet sent along datapackets when first block is requested.

There is a DoRetry routine that checks all files in progress and resends 
requests if no reply had been received in timeout, to accomodate for packet 
loss. There is also a timeout, uppon exceding the transfer is aborted.

The new approach
----------------

Support for inetd has to be dropped for now. The daemon must be run as 
standalone service, becouse we need presistent program state.

The list of peers is stored in memory. It is loaded from file on 
initialization and saved regulary (in doAkafuka, maybe). Peers are 
akafukaed individualy.

State of filetransfers is stored in a linked list so that completed parts 
could be unlinked fast. Uncompleted parts are (re)requested once in a 
while, every time only fixed amoult of parts are requested, to not overload 
network. The state is saved periodically to be able to restore the transfer.

The state file is searched too often, this kills the boost of linked list. 
FIXME. We should use sonething like chk.part filename to fix problems on 
unfinished files treating as finidshed. Fix the error cases!

Only data files are alloved to be pieced. Assembly of pieced files is 
performed on higher level than transfer. Support for pieced files is 
planned, but low priority.

Whenever a new peer is seen, PGP key is requested from it. Also share 
request is made with the current "interested in" tags.

There is a list of share offers waiting acknowledgement. Theese are 
retransmitted every once in a while. (Should also requests be 
retransmitted?)

Web Interface
-------------

There will definitly be better interface implemented on top of the former, 
but running in separate process.

Some progress happened on this.

