Brod Net concept
================

The network is going to cover two modes of operation.

1. Mesh network
2. Owerlay network

And should serve the following

1. Verifiable Files
2. Named Files
3. Keyword Searches
4. MeSsages

Programs
--------

INetD (or WhatnotNetD) listens for incomming connections. When packet 
arrives, brodnetd is started (STDIN is the socket) to handle it and all 
subsequent packets. When the instance of brodnetd terminates or detaches 
itsevf, the corresponding NetD can start another instance when a packet 
arrives.

When the brodnetd wants to send a packet, it reuses the socket it possible. 
Othervise a new socket is created.

This means that there can be possibly multiple instances of brodnetd 
running, so approportiate database locking should be implemented.

Discovery
---------

The node finds its peers by sending a local area broadcasts (LAND). It is 
performed by sending Hello packet to all devices in range of all network 
interfaces.

The second mode of discovery is wide area node discovery (WAND). It is 
performed by sending an AskNodes packet to all peers in node list, which 
should reply with list of nodes. The node then tryies to send Hello packet 
to discovered nodes directly. If successfull (eg: in Internet), it uses 
them as peers. If unsuccessfull (eg: in Meshnet), it updates its routing 
table.

### Note on key sizes

2048 RSA signing keys with SHA256 digest are ok (about 0.5kiB). DSA keys are preffered.
The whole hello.dat.gpg has to fit in one UDP packet (max 1kiB).

The hello.dat has one 20B Fingerprint, and like 48 4B Area codes ==212B.

The signature is MAX 512B.

Packet is 725B.

Greetings (Hellos)
------------------

Hello consist only of fingerprint. It has to be short for effective 
broadcast. Hello is used to find new peers (LAND) as well as to check 
availability of peers.

### If node recieves an Hello

- in cHelloCooldown since last Hello from the same peer,
  no further actions are performed

- it sends Hi in reply.
  Hi packet consist of fingerprint and network address of the sender of the 
  Hello. This could be possibly used for STUN.

- it adds the sender to list of peers.
 
Greetings (Hi)
--------------

Hi packets are used as a reply for Hello. They inform the sender of the 
Hello of his SockAddr.

Key Retrival
------------

Becouse the Hello packets are signed with pgp public key, this key has to 
be retrived to verifi the authenticity of the packets.

Keys are retrived as normal VFs identified as /vf/gpg/<fingerprint>.

Areas
-----

Each node has an area record. A node can find its area record from its 
peers. The area record is used to accelerate routing.

The area record is just list of area codes. An area code is 32bit 
number and specifies a geological or fictional location of the node.
There are usually more area codes in area record of a given node.

When there are too much nodes in an area, new area should be created. When 
there are too litle nodes in area, the area code is abadoned.

The area codes could be possibly created and managed autmomatically, but 
now they are managed by administrator.

INet
-----

Xinetd is going to listen for all connections.

Daemon Lifecycle
================

Daemon is started by netd with stdin/stdout connected to socket. A packet 
is recieved (rcvmsg) from the socket and parsed. Depending on the type and 
contents of the packet, approportiate action is taken. If reply should be 
sent, new datagram socket is created and the socaddr is used as 
destination. Then the daemon listens for another packet with configurable 
timeout. If no packet was received in time, daemon exits. And netd listens 
again.

File Sharing
============

All files in the network have tags. Files are found only by their tags.

Comm
----

Note: 'tags' is array of hash of tagstring.

1. -> FileShare.T (hash = 0, tags)
2. 
   * <- FileShare.T (hash = 1, tags)
   * <- FileShare.T (hash = 2, tags)
   * <- FileShare.T (hash = 3, tags)
3. -> FileTrans.tYes (hash = 2)
4. 
   * <- FileTrans.tPcs (hash = 2, order = 1, total = 2, pcs=(a,...) )
   * <- FileTrans.tPcs (hash = 2, order = 2, total = 2, pcs=(...) )
5. -> FileTransfer.tYes (hash = a)
6. <- FileTransfer.tData (hash = a, data=(...) )

Tags
----

Every file has max of 200 tags (to not fragment search packets).
